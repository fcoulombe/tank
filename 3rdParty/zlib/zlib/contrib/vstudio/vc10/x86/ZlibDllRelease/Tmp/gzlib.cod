; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\src\kinevox\3rdParty\zlib\zlib\gzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	_sprintf:PROC
EXTRN	_wcstombs:PROC
EXTRN	__wopen:PROC
EXTRN	_open:PROC
EXTRN	__lseeki64:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
PUBLIC	_gz_error
; Function compile flags: /Ogtp
; File c:\src\kinevox\3rdparty\zlib\zlib\gzlib.c
;	COMDAT _gz_error
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_gz_error PROC						; COMDAT
; _state$ = ecx
; _err$ = eax

; 568  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
  00007	8b f0		 mov	 esi, eax

; 569  :     /* free previously allocated message and clear */
; 570  :     if (state->msg != NULL) {

  00009	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0000c	85 c0		 test	 eax, eax
  0000e	74 16		 je	 SHORT $LN16@gz_error

; 571  :         if (state->err != Z_MEM_ERROR)

  00010	83 7f 5c fc	 cmp	 DWORD PTR [edi+92], -4	; fffffffcH
  00014	74 09		 je	 SHORT $LN5@gz_error

; 572  :             free(state->msg);

  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _free
  0001c	83 c4 04	 add	 esp, 4
$LN5@gz_error:

; 573  :         state->msg = NULL;

  0001f	c7 47 60 00 00
	00 00		 mov	 DWORD PTR [edi+96], 0
$LN16@gz_error:

; 574  :     }
; 575  : 
; 576  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 577  :     if (err != Z_OK && err != Z_BUF_ERROR)

  00026	85 f6		 test	 esi, esi
  00028	74 0b		 je	 SHORT $LN4@gz_error
  0002a	83 fe fb	 cmp	 esi, -5			; fffffffbH
  0002d	74 06		 je	 SHORT $LN4@gz_error

; 578  :         state->x.have = 0;

  0002f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN4@gz_error:

; 579  : 
; 580  :     /* set error code, and if no message, then done */
; 581  :     state->err = err;
; 582  :     if (msg == NULL)

  00035	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00038	89 77 5c	 mov	 DWORD PTR [edi+92], esi
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 b5 00 00
	00		 je	 $LN7@gz_error

; 583  :         return;
; 584  : 
; 585  :     /* for an out of memory error, save as static string */
; 586  :     if (err == Z_MEM_ERROR) {

  00043	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00046	75 07		 jne	 SHORT $LN2@gz_error

; 587  :         state->msg = (char *)msg;

  00048	89 47 60	 mov	 DWORD PTR [edi+96], eax
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi

; 600  :     return;
; 601  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN2@gz_error:
  0004f	53		 push	 ebx

; 588  :         return;
; 589  :     }
; 590  : 
; 591  :     /* construct error message with path */
; 592  :     if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

  00050	8b 5f 18	 mov	 ebx, DWORD PTR [edi+24]
  00053	8b c3		 mov	 eax, ebx
  00055	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL11@gz_error:
  00058	8a 08		 mov	 cl, BYTE PTR [eax]
  0005a	40		 inc	 eax
  0005b	84 c9		 test	 cl, cl
  0005d	75 f9		 jne	 SHORT $LL11@gz_error
  0005f	2b c2		 sub	 eax, edx
  00061	8b d0		 mov	 edx, eax
  00063	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00066	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL12@gz_error:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	40		 inc	 eax
  00073	84 c9		 test	 cl, cl
  00075	75 f9		 jne	 SHORT $LL12@gz_error
  00077	2b c6		 sub	 eax, esi
  00079	8d 44 10 03	 lea	 eax, DWORD PTR [eax+edx+3]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _malloc
  00083	83 c4 04	 add	 esp, 4
  00086	89 47 60	 mov	 DWORD PTR [edi+96], eax
  00089	85 c0		 test	 eax, eax
  0008b	75 13		 jne	 SHORT $LN1@gz_error

; 593  :         state->err = Z_MEM_ERROR;

  0008d	5b		 pop	 ebx
  0008e	c7 47 5c fc ff
	ff ff		 mov	 DWORD PTR [edi+92], -4	; fffffffcH

; 594  :         state->msg = (char *)"out of memory";

  00095	c7 47 60 00 00
	00 00		 mov	 DWORD PTR [edi+96], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 600  :     return;
; 601  : }

  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN1@gz_error:

; 595  :         return;
; 596  :     }
; 597  :     strcpy(state->msg, state->path);

  000a0	8b cb		 mov	 ecx, ebx
  000a2	8b d0		 mov	 edx, eax
$LL9@gz_error:
  000a4	8a 01		 mov	 al, BYTE PTR [ecx]
  000a6	88 02		 mov	 BYTE PTR [edx], al
  000a8	41		 inc	 ecx
  000a9	42		 inc	 edx
  000aa	84 c0		 test	 al, al
  000ac	75 f6		 jne	 SHORT $LL9@gz_error

; 598  :     strcat(state->msg, ": ");

  000ae	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  000b1	48		 dec	 eax
$LL13@gz_error:
  000b2	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000b5	40		 inc	 eax
  000b6	84 c9		 test	 cl, cl
  000b8	75 f8		 jne	 SHORT $LL13@gz_error
  000ba	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_02LMMGGCAJ@?3?5?$AA@
  000c1	66 89 08	 mov	 WORD PTR [eax], cx
  000c4	8a 15 02 00 00
	00		 mov	 dl, BYTE PTR ??_C@_02LMMGGCAJ@?3?5?$AA@+2
  000ca	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 599  :     strcat(state->msg, msg);

  000cd	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  000d0	8b c8		 mov	 ecx, eax
$LL14@gz_error:
  000d2	8a 10		 mov	 dl, BYTE PTR [eax]
  000d4	40		 inc	 eax
  000d5	84 d2		 test	 dl, dl
  000d7	75 f9		 jne	 SHORT $LL14@gz_error
  000d9	8b 7f 60	 mov	 edi, DWORD PTR [edi+96]
  000dc	2b c1		 sub	 eax, ecx
  000de	8b f1		 mov	 esi, ecx
  000e0	4f		 dec	 edi
$LL15@gz_error:
  000e1	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000e4	47		 inc	 edi
  000e5	84 c9		 test	 cl, cl
  000e7	75 f8		 jne	 SHORT $LL15@gz_error
  000e9	8b c8		 mov	 ecx, eax
  000eb	c1 e9 02	 shr	 ecx, 2
  000ee	f3 a5		 rep movsd
  000f0	8b c8		 mov	 ecx, eax
  000f2	83 e1 03	 and	 ecx, 3
  000f5	f3 a4		 rep movsb
  000f7	5b		 pop	 ebx
$LN7@gz_error:
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 600  :     return;
; 601  : }

  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
_gz_error ENDP
_TEXT	ENDS
PUBLIC	_gzclearerr@4
; Function compile flags: /Ogtp
;	COMDAT _gzclearerr@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclearerr@4 PROC					; COMDAT

; 540  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 541  :     gz_statep state;
; 542  : 
; 543  :     /* get internal structure and check integrity */
; 544  :     if (file == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	3b ca		 cmp	 ecx, edx
  0000a	74 29		 je	 SHORT $LN4@gzclearerr

; 545  :         return;
; 546  :     state = (gz_statep)file;
; 547  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000f	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00014	74 0e		 je	 SHORT $LN7@gzclearerr
  00016	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  0001b	75 18		 jne	 SHORT $LN4@gzclearerr

; 548  :         return;
; 549  : 
; 550  :     /* clear error and end-of-file */
; 551  :     if (state->mode == GZ_READ) {

  0001d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00022	75 06		 jne	 SHORT $LN1@gzclearerr
$LN7@gzclearerr:

; 552  :         state->eof = 0;

  00024	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 553  :         state->past = 0;

  00027	89 51 44	 mov	 DWORD PTR [ecx+68], edx
$LN1@gzclearerr:

; 554  :     }
; 555  :     gz_error(state, Z_OK, NULL);

  0002a	52		 push	 edx
  0002b	33 c0		 xor	 eax, eax
  0002d	e8 00 00 00 00	 call	 _gz_error
  00032	83 c4 04	 add	 esp, 4
$LN4@gzclearerr:

; 556  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_gzclearerr@4 ENDP
_TEXT	ENDS
PUBLIC	_gzerror@8
; Function compile flags: /Ogtp
;	COMDAT _gzerror@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_errnum$ = 12						; size = 4
_gzerror@8 PROC						; COMDAT

; 521  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 522  :     gz_statep state;
; 523  : 
; 524  :     /* get internal structure and check integrity */
; 525  :     if (file == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 06		 jne	 SHORT $LN3@gzerror
$LN8@gzerror:

; 526  :         return NULL;

  0000a	33 c0		 xor	 eax, eax

; 535  : }

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
$LN3@gzerror:

; 527  :     state = (gz_statep)file;
; 528  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00010	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00013	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  00019	74 08		 je	 SHORT $LN2@gzerror
  0001b	81 f9 b1 79 00
	00		 cmp	 ecx, 31153		; 000079b1H

; 529  :         return NULL;

  00021	75 e7		 jne	 SHORT $LN8@gzerror
$LN2@gzerror:

; 530  : 
; 531  :     /* return error information */
; 532  :     if (errnum != NULL)

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _errnum$[ebp]
  00026	85 c9		 test	 ecx, ecx
  00028	74 05		 je	 SHORT $LN1@gzerror

; 533  :         *errnum = state->err;

  0002a	8b 50 5c	 mov	 edx, DWORD PTR [eax+92]
  0002d	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@gzerror:

; 534  :     return state->msg == NULL ? "" : state->msg;

  0002f	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00032	85 c0		 test	 eax, eax
  00034	75 05		 jne	 SHORT $LN4@gzerror
  00036	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@gzerror:

; 535  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
_gzerror@8 ENDP
_TEXT	ENDS
PUBLIC	_gzeof@4
; Function compile flags: /Ogtp
;	COMDAT _gzeof@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzeof@4 PROC						; COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 504  :     gz_statep state;
; 505  : 
; 506  :     /* get internal structure and check integrity */
; 507  :     if (file == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	85 c9		 test	 ecx, ecx

; 508  :         return 0;

  00008	74 1f		 je	 SHORT $LN5@gzeof

; 509  :     state = (gz_statep)file;
; 510  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00012	74 0e		 je	 SHORT $LN8@gzeof
  00014	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 511  :         return 0;

  00019	75 0e		 jne	 SHORT $LN5@gzeof

; 512  : 
; 513  :     /* return end-of-file state */
; 514  :     return state->mode == GZ_READ ? state->past : 0;

  0001b	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00020	75 07		 jne	 SHORT $LN5@gzeof
$LN8@gzeof:
  00022	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 515  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN5@gzeof:

; 512  : 
; 513  :     /* return end-of-file state */
; 514  :     return state->mode == GZ_READ ? state->past : 0;

  00029	33 c0		 xor	 eax, eax

; 515  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_gzeof@4 ENDP
_TEXT	ENDS
PUBLIC	_gzoffset64@4
; Function compile flags: /Ogtp
;	COMDAT _gzoffset64@4
_TEXT	SEGMENT
_gzoffset64@4 PROC					; COMDAT
; _file$ = esi

; 471  :     z_off64_t offset;
; 472  :     gz_statep state;
; 473  : 
; 474  :     /* get internal structure and check integrity */
; 475  :     if (file == NULL)

  00000	85 f6		 test	 esi, esi
  00002	75 06		 jne	 SHORT $LN4@gzoffset64
$LN7@gzoffset64:

; 476  :         return -1;

  00004	83 c8 ff	 or	 eax, -1
  00007	0b d0		 or	 edx, eax

; 487  :     return offset;
; 488  : }

  00009	c3		 ret	 0
$LN4@gzoffset64:

; 477  :     state = (gz_statep)file;
; 478  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00012	74 07		 je	 SHORT $LN3@gzoffset64
  00014	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 479  :         return -1;

  00019	75 e9		 jne	 SHORT $LN7@gzoffset64
$LN3@gzoffset64:

; 480  : 
; 481  :     /* compute and return effective offset in file */
; 482  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  0001b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0001e	6a 01		 push	 1
  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 __lseeki64

; 483  :     if (offset == -1)

  0002a	8b c8		 mov	 ecx, eax
  0002c	23 ca		 and	 ecx, edx
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
  00031	83 f9 ff	 cmp	 ecx, -1

; 484  :         return -1;

  00034	74 ce		 je	 SHORT $LN7@gzoffset64

; 485  :     if (state->mode == GZ_READ)             /* reading */

  00036	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  0003d	75 06		 jne	 SHORT $LN5@gzoffset64

; 486  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  0003f	2b 46 68	 sub	 eax, DWORD PTR [esi+104]
  00042	83 da 00	 sbb	 edx, 0
$LN5@gzoffset64:

; 487  :     return offset;
; 488  : }

  00045	c3		 ret	 0
_gzoffset64@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell64@4
; Function compile flags: /Ogtp
;	COMDAT _gztell64@4
_TEXT	SEGMENT
_gztell64@4 PROC					; COMDAT
; _file$ = ecx

; 444  :     gz_statep state;
; 445  : 
; 446  :     /* get internal structure and check integrity */
; 447  :     if (file == NULL)

  00000	85 c9		 test	 ecx, ecx
  00002	75 06		 jne	 SHORT $LN2@gztell64
$LN7@gztell64:

; 448  :         return -1;

  00004	83 c8 ff	 or	 eax, -1
  00007	0b d0		 or	 edx, eax

; 455  : }

  00009	c3		 ret	 0
$LN2@gztell64:

; 449  :     state = (gz_statep)file;
; 450  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00012	74 07		 je	 SHORT $LN1@gztell64
  00014	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 451  :         return -1;

  00019	75 e9		 jne	 SHORT $LN7@gztell64
$LN1@gztell64:

; 452  : 
; 453  :     /* return position */
; 454  :     return state->x.pos + (state->seek ? state->skip : 0);

  0001b	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  0001f	56		 push	 esi
  00020	74 12		 je	 SHORT $LN5@gztell64
  00022	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00028	8b 71 54	 mov	 esi, DWORD PTR [ecx+84]
  0002b	03 c2		 add	 eax, edx
  0002d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00030	13 d6		 adc	 edx, esi
  00032	5e		 pop	 esi

; 455  : }

  00033	c3		 ret	 0
$LN5@gztell64:

; 452  : 
; 453  :     /* return position */
; 454  :     return state->x.pos + (state->seek ? state->skip : 0);

  00034	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00037	33 d2		 xor	 edx, edx
  00039	33 f6		 xor	 esi, esi
  0003b	03 c2		 add	 eax, edx
  0003d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00040	13 d6		 adc	 edx, esi
  00042	5e		 pop	 esi

; 455  : }

  00043	c3		 ret	 0
_gztell64@4 ENDP
_TEXT	ENDS
PUBLIC	_gzbuffer@8
; Function compile flags: /Ogtp
;	COMDAT _gzbuffer@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_size$ = 12						; size = 4
_gzbuffer@8 PROC					; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :     gz_statep state;
; 309  : 
; 310  :     /* get internal structure and check integrity */
; 311  :     if (file == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 07		 jne	 SHORT $LN4@gzbuffer
$LN7@gzbuffer:

; 312  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1

; 326  : }

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
$LN4@gzbuffer:

; 313  :     state = (gz_statep)file;
; 314  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00011	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00014	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00019	74 07		 je	 SHORT $LN3@gzbuffer
  0001b	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 315  :         return -1;

  00020	75 e8		 jne	 SHORT $LN7@gzbuffer
$LN3@gzbuffer:

; 316  : 
; 317  :     /* make sure we haven't already allocated memory */
; 318  :     if (state->size != 0)

  00022	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0

; 319  :         return -1;

  00026	75 e2		 jne	 SHORT $LN7@gzbuffer

; 320  : 
; 321  :     /* check and set requested size */
; 322  :     if (size < 2)

  00028	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0002b	83 f8 02	 cmp	 eax, 2
  0002e	73 05		 jae	 SHORT $LN1@gzbuffer

; 323  :         size = 2;               /* need two bytes to check magic header */

  00030	b8 02 00 00 00	 mov	 eax, 2
$LN1@gzbuffer:

; 324  :     state->want = size;

  00035	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 325  :     return 0;

  00038	33 c0		 xor	 eax, eax

; 326  : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_gzbuffer@8 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gz_reset
_TEXT	SEGMENT
_gz_reset PROC						; COMDAT
; _state$ = esi

; 77   : {

  00000	57		 push	 edi

; 78   :     state->x.have = 0;              /* no output data available */

  00001	33 ff		 xor	 edi, edi

; 79   :     if (state->mode == GZ_READ) {   /* for reading ... */

  00003	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  0000a	89 3e		 mov	 DWORD PTR [esi], edi
  0000c	75 09		 jne	 SHORT $LN1@gz_reset

; 80   :         state->eof = 0;             /* not at end of file */

  0000e	89 7e 40	 mov	 DWORD PTR [esi+64], edi

; 81   :         state->past = 0;            /* have not read past end yet */

  00011	89 7e 44	 mov	 DWORD PTR [esi+68], edi

; 82   :         state->how = LOOK;          /* look for gzip header */

  00014	89 7e 30	 mov	 DWORD PTR [esi+48], edi
$LN1@gz_reset:

; 83   :     }
; 84   :     state->seek = 0;                /* no seek request pending */
; 85   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00017	57		 push	 edi
  00018	33 c0		 xor	 eax, eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  0001f	e8 00 00 00 00	 call	 _gz_error
  00024	83 c4 04	 add	 esp, 4

; 86   :     state->x.pos = 0;               /* no uncompressed data yet */

  00027	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002a	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 87   :     state->strm.avail_in = 0;       /* no input data yet */

  0002d	89 7e 68	 mov	 DWORD PTR [esi+104], edi
  00030	5f		 pop	 edi

; 88   : }

  00031	c3		 ret	 0
_gz_reset ENDP
PUBLIC	_gzoffset@4
; Function compile flags: /Ogtp
;	COMDAT _gzoffset@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzoffset@4 PROC					; COMDAT

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi

; 494  :     z_off64_t ret;
; 495  : 
; 496  :     ret = gzoffset64(file);

  00008	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000b	e8 00 00 00 00	 call	 _gzoffset64@4
  00010	8b c8		 mov	 ecx, eax
  00012	8b f2		 mov	 esi, edx

; 497  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00014	99		 cdq
  00015	3b c8		 cmp	 ecx, eax
  00017	75 0d		 jne	 SHORT $LN3@gzoffset
  00019	3b f2		 cmp	 esi, edx
  0001b	75 09		 jne	 SHORT $LN3@gzoffset
  0001d	8b c1		 mov	 eax, ecx

; 498  : }

  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@gzoffset:

; 497  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00026	83 c8 ff	 or	 eax, -1

; 498  : }

  00029	5e		 pop	 esi
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
_gzoffset@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell@4
; Function compile flags: /Ogtp
;	COMDAT _gztell@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gztell@4 PROC						; COMDAT

; 460  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 461  :     z_off64_t ret;
; 462  : 
; 463  :     ret = gztell64(file);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	56		 push	 esi
  00007	e8 00 00 00 00	 call	 _gztell64@4
  0000c	8b c8		 mov	 ecx, eax
  0000e	8b f2		 mov	 esi, edx

; 464  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00010	99		 cdq
  00011	3b c8		 cmp	 ecx, eax
  00013	75 0b		 jne	 SHORT $LN3@gztell
  00015	3b f2		 cmp	 esi, edx
  00017	75 07		 jne	 SHORT $LN3@gztell
  00019	8b c1		 mov	 eax, ecx
  0001b	5e		 pop	 esi

; 465  : }

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN3@gztell:

; 464  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00020	83 c8 ff	 or	 eax, -1
  00023	5e		 pop	 esi

; 465  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
_gztell@4 ENDP
_TEXT	ENDS
PUBLIC	_gzrewind@4
; Function compile flags: /Ogtp
;	COMDAT _gzrewind@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzrewind@4 PROC					; COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi

; 332  :     gz_statep state;
; 333  : 
; 334  :     /* get internal structure */
; 335  :     if (file == NULL)

  00008	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000b	85 f6		 test	 esi, esi

; 336  :         return -1;

  0000d	74 40		 je	 SHORT $LN2@gzrewind

; 337  :     state = (gz_statep)file;
; 338  : 
; 339  :     /* check that we're reading and that there's no error */
; 340  :     if (state->mode != GZ_READ ||
; 341  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0000f	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  00016	75 37		 jne	 SHORT $LN2@gzrewind
  00018	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0001b	85 c0		 test	 eax, eax
  0001d	74 05		 je	 SHORT $LN3@gzrewind
  0001f	83 f8 fb	 cmp	 eax, -5			; fffffffbH
  00022	75 2b		 jne	 SHORT $LN2@gzrewind
$LN3@gzrewind:

; 343  : 
; 344  :     /* back up and start over */
; 345  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  00024	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00027	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0002a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002d	6a 00		 push	 0
  0002f	50		 push	 eax
  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 __lseeki64
  00037	23 c2		 and	 eax, edx
  00039	83 c4 10	 add	 esp, 16			; 00000010H
  0003c	83 f8 ff	 cmp	 eax, -1

; 346  :         return -1;

  0003f	74 0e		 je	 SHORT $LN2@gzrewind

; 347  :     gz_reset(state);

  00041	e8 00 00 00 00	 call	 _gz_reset

; 348  :     return 0;

  00046	33 c0		 xor	 eax, eax

; 349  : }

  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN2@gzrewind:

; 342  :         return -1;

  0004f	83 c8 ff	 or	 eax, -1

; 349  : }

  00052	5e		 pop	 esi
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
_gzrewind@4 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gz_open
_TEXT	SEGMENT
tv149 = -8						; size = 4
_exclusive$ = -4					; size = 4
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_gz_open PROC						; COMDAT
; _mode$ = eax

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 96   :     gz_statep state;
; 97   :     size_t len;
; 98   :     int oflag;
; 99   : #ifdef O_CLOEXEC
; 100  :     int cloexec = 0;
; 101  : #endif
; 102  : #ifdef O_EXCL
; 103  :     int exclusive = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	57		 push	 edi
  0000a	8b f8		 mov	 edi, eax
  0000c	89 5d fc	 mov	 DWORD PTR _exclusive$[ebp], ebx

; 104  : #endif
; 105  : 
; 106  :     /* check input */
; 107  :     if (path == NULL)

  0000f	39 5d 08	 cmp	 DWORD PTR _path$[ebp], ebx
  00012	75 08		 jne	 SHORT $LN35@gz_open

; 108  :         return NULL;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax
  00017	5b		 pop	 ebx

; 259  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN35@gz_open:
  0001c	56		 push	 esi

; 109  : 
; 110  :     /* allocate gzFile structure to return */
; 111  :     state = malloc(sizeof(gz_state));

  0001d	68 a0 00 00 00	 push	 160			; 000000a0H
  00022	e8 00 00 00 00	 call	 _malloc
  00027	8b f0		 mov	 esi, eax
  00029	83 c4 04	 add	 esp, 4

; 112  :     if (state == NULL)

  0002c	3b f3		 cmp	 esi, ebx

; 113  :         return NULL;

  0002e	0f 84 d1 01 00
	00		 je	 $LN53@gz_open

; 114  :     state->size = 0;            /* no buffers allocated yet */
; 115  :     state->want = GZBUFSIZE;    /* requested buffer size */
; 116  :     state->msg = NULL;          /* no error message yet */
; 117  : 
; 118  :     /* interpret mode */
; 119  :     state->mode = GZ_NONE;
; 120  :     state->level = Z_DEFAULT_COMPRESSION;
; 121  :     state->strategy = Z_DEFAULT_STRATEGY;
; 122  :     state->direct = 0;
; 123  :     while (*mode) {

  00034	8a 07		 mov	 al, BYTE PTR [edi]
  00036	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  00039	c7 46 20 00 20
	00 00		 mov	 DWORD PTR [esi+32], 8192 ; 00002000H
  00040	89 5e 60	 mov	 DWORD PTR [esi+96], ebx
  00043	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00046	c7 46 48 ff ff
	ff ff		 mov	 DWORD PTR [esi+72], -1
  0004d	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
  00050	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
  00053	84 c0		 test	 al, al
  00055	0f 84 81 00 00
	00		 je	 $LN32@gz_open
  0005b	ba 03 00 00 00	 mov	 edx, 3
  00060	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL33@gz_open:

; 124  :         if (*mode >= '0' && *mode <= '9')

  00063	3c 30		 cmp	 al, 48			; 00000030H
  00065	7c 0f		 jl	 SHORT $LN31@gz_open
  00067	3c 39		 cmp	 al, 57			; 00000039H
  00069	7f 0b		 jg	 SHORT $LN31@gz_open

; 125  :             state->level = *mode - '0';

  0006b	0f be c0	 movsx	 eax, al
  0006e	83 e8 30	 sub	 eax, 48			; 00000030H
  00071	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 126  :         else

  00074	eb 5e		 jmp	 SHORT $LN50@gz_open
$LN31@gz_open:

; 127  :             switch (*mode) {

  00076	0f be c0	 movsx	 eax, al
  00079	83 c0 d5	 add	 eax, -43		; ffffffd5H
  0007c	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0007f	77 53		 ja	 SHORT $LN50@gz_open
  00081	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN48@gz_open[eax]
  00088	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN55@gz_open[eax*4]
$LN27@gz_open:

; 128  :             case 'r':
; 129  :                 state->mode = GZ_READ;

  0008f	c7 46 10 4f 1c
	00 00		 mov	 DWORD PTR [esi+16], 7247 ; 00001c4fH

; 130  :                 break;

  00096	eb 3c		 jmp	 SHORT $LN50@gz_open
$LN26@gz_open:

; 131  : #ifndef NO_GZCOMPRESS
; 132  :             case 'w':
; 133  :                 state->mode = GZ_WRITE;

  00098	c7 46 10 b1 79
	00 00		 mov	 DWORD PTR [esi+16], 31153 ; 000079b1H

; 134  :                 break;

  0009f	eb 33		 jmp	 SHORT $LN50@gz_open
$LN25@gz_open:

; 135  :             case 'a':
; 136  :                 state->mode = GZ_APPEND;

  000a1	c7 46 10 01 00
	00 00		 mov	 DWORD PTR [esi+16], 1

; 137  :                 break;

  000a8	eb 2a		 jmp	 SHORT $LN50@gz_open
$LN22@gz_open:

; 138  : #endif
; 139  :             case '+':       /* can't read and write at the same time */
; 140  :                 free(state);
; 141  :                 return NULL;
; 142  :             case 'b':       /* ignore -- will request binary anyway */
; 143  :                 break;
; 144  : #ifdef O_CLOEXEC
; 145  :             case 'e':
; 146  :                 cloexec = 1;
; 147  :                 break;
; 148  : #endif
; 149  : #ifdef O_EXCL
; 150  :             case 'x':
; 151  :                 exclusive = 1;

  000aa	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _exclusive$[ebp], 1

; 152  :                 break;

  000b1	eb 21		 jmp	 SHORT $LN50@gz_open
$LN21@gz_open:

; 153  : #endif
; 154  :             case 'f':
; 155  :                 state->strategy = Z_FILTERED;

  000b3	c7 46 4c 01 00
	00 00		 mov	 DWORD PTR [esi+76], 1

; 156  :                 break;

  000ba	eb 18		 jmp	 SHORT $LN50@gz_open
$LN20@gz_open:

; 157  :             case 'h':
; 158  :                 state->strategy = Z_HUFFMAN_ONLY;

  000bc	c7 46 4c 02 00
	00 00		 mov	 DWORD PTR [esi+76], 2

; 159  :                 break;

  000c3	eb 0f		 jmp	 SHORT $LN50@gz_open
$LN19@gz_open:

; 160  :             case 'R':
; 161  :                 state->strategy = Z_RLE;

  000c5	89 56 4c	 mov	 DWORD PTR [esi+76], edx

; 162  :                 break;

  000c8	eb 0a		 jmp	 SHORT $LN50@gz_open
$LN18@gz_open:

; 163  :             case 'F':
; 164  :                 state->strategy = Z_FIXED;

  000ca	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
$LN17@gz_open:

; 165  :             case 'T':
; 166  :                 state->direct = 1;

  000cd	c7 46 2c 01 00
	00 00		 mov	 DWORD PTR [esi+44], 1
$LN50@gz_open:

; 114  :     state->size = 0;            /* no buffers allocated yet */
; 115  :     state->want = GZBUFSIZE;    /* requested buffer size */
; 116  :     state->msg = NULL;          /* no error message yet */
; 117  : 
; 118  :     /* interpret mode */
; 119  :     state->mode = GZ_NONE;
; 120  :     state->level = Z_DEFAULT_COMPRESSION;
; 121  :     state->strategy = Z_DEFAULT_STRATEGY;
; 122  :     state->direct = 0;
; 123  :     while (*mode) {

  000d4	8a 47 01	 mov	 al, BYTE PTR [edi+1]

; 167  :             default:        /* could consider as an error, but just ignore */
; 168  :                 ;
; 169  :             }
; 170  :         mode++;

  000d7	47		 inc	 edi
  000d8	84 c0		 test	 al, al
  000da	75 87		 jne	 SHORT $LL33@gz_open
$LN32@gz_open:

; 171  :     }
; 172  : 
; 173  :     /* must provide an "r", "w", or "a" */
; 174  :     if (state->mode == GZ_NONE) {

  000dc	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000df	3b c3		 cmp	 eax, ebx

; 175  :         free(state);
; 176  :         return NULL;

  000e1	74 5e		 je	 SHORT $LN54@gz_open

; 177  :     }
; 178  : 
; 179  :     /* can't force transparent read */
; 180  :     if (state->mode == GZ_READ) {

  000e3	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  000e8	75 0c		 jne	 SHORT $LN14@gz_open

; 181  :         if (state->direct) {

  000ea	39 5e 2c	 cmp	 DWORD PTR [esi+44], ebx

; 182  :             free(state);
; 183  :             return NULL;

  000ed	75 52		 jne	 SHORT $LN54@gz_open

; 184  :         }
; 185  :         state->direct = 1;      /* for empty file */

  000ef	c7 46 2c 01 00
	00 00		 mov	 DWORD PTR [esi+44], 1
$LN14@gz_open:

; 186  :     }
; 187  : 
; 188  :     /* save the path name for error messages */
; 189  : #ifdef _WIN32
; 190  :     if (fd == -2) {

  000f6	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  000fa	75 19		 jne	 SHORT $LN12@gz_open

; 191  :         len = wcstombs(NULL, path, 0);

  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  000ff	53		 push	 ebx
  00100	51		 push	 ecx
  00101	53		 push	 ebx
  00102	e8 00 00 00 00	 call	 _wcstombs
  00107	8b f8		 mov	 edi, eax
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH

; 192  :         if (len == (size_t)-1)

  0010c	83 ff ff	 cmp	 edi, -1
  0010f	75 1a		 jne	 SHORT $LN10@gz_open

; 193  :             len = 0;

  00111	33 ff		 xor	 edi, edi

; 194  :     }
; 195  :     else

  00113	eb 16		 jmp	 SHORT $LN10@gz_open
$LN12@gz_open:

; 196  : #endif
; 197  :         len = strlen(path);

  00115	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  00118	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0011b	eb 03 8d 49 00	 npad	 5
$LL49@gz_open:
  00120	8a 08		 mov	 cl, BYTE PTR [eax]
  00122	40		 inc	 eax
  00123	84 c9		 test	 cl, cl
  00125	75 f9		 jne	 SHORT $LL49@gz_open
  00127	2b c2		 sub	 eax, edx
  00129	8b f8		 mov	 edi, eax
$LN10@gz_open:

; 198  :     state->path = malloc(len + 1);

  0012b	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  0012e	53		 push	 ebx
  0012f	e8 00 00 00 00	 call	 _malloc
  00134	83 c4 04	 add	 esp, 4
  00137	89 45 f8	 mov	 DWORD PTR tv149[ebp], eax
  0013a	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 199  :     if (state->path == NULL) {

  0013d	85 c0		 test	 eax, eax
  0013f	75 12		 jne	 SHORT $LN9@gz_open
$LN54@gz_open:

; 200  :         free(state);

  00141	56		 push	 esi
  00142	e8 00 00 00 00	 call	 _free
  00147	83 c4 04	 add	 esp, 4
  0014a	5e		 pop	 esi
  0014b	5f		 pop	 edi

; 201  :         return NULL;

  0014c	33 c0		 xor	 eax, eax
  0014e	5b		 pop	 ebx

; 259  : }

  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
$LN9@gz_open:

; 202  :     }
; 203  : #ifdef _WIN32
; 204  :     if (fd == -2)

  00153	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  00157	75 19		 jne	 SHORT $LN8@gz_open

; 205  :         if (len)

  00159	85 ff		 test	 edi, edi
  0015b	74 10		 je	 SHORT $LN7@gz_open

; 206  :             wcstombs(state->path, path, len + 1);

  0015d	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  00160	53		 push	 ebx
  00161	52		 push	 edx
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _wcstombs
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH

; 207  :         else

  0016b	eb 14		 jmp	 SHORT $LN5@gz_open
$LN7@gz_open:

; 208  :             *(state->path) = 0;

  0016d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 209  :     else

  00170	eb 0f		 jmp	 SHORT $LN5@gz_open
$LN8@gz_open:

; 210  : #endif
; 211  :         strcpy(state->path, path);

  00172	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00175	8b d0		 mov	 edx, eax
$LL38@gz_open:
  00177	8a 01		 mov	 al, BYTE PTR [ecx]
  00179	88 02		 mov	 BYTE PTR [edx], al
  0017b	41		 inc	 ecx
  0017c	42		 inc	 edx
  0017d	84 c0		 test	 al, al
  0017f	75 f6		 jne	 SHORT $LL38@gz_open
$LN5@gz_open:

; 212  : 
; 213  :     /* compute the flags for open() */
; 214  :     oflag =
; 215  : #ifdef O_LARGEFILE
; 216  :         O_LARGEFILE |
; 217  : #endif
; 218  : #ifdef O_BINARY
; 219  :         O_BINARY |
; 220  : #endif
; 221  : #ifdef O_CLOEXEC
; 222  :         (cloexec ? O_CLOEXEC : 0) |
; 223  : #endif
; 224  :         (state->mode == GZ_READ ?
; 225  :          O_RDONLY :
; 226  :          (O_WRONLY | O_CREAT |
; 227  : #ifdef O_EXCL
; 228  :           (exclusive ? O_EXCL : 0) |
; 229  : #endif
; 230  :           (state->mode == GZ_WRITE ?
; 231  :            O_TRUNC :
; 232  :            O_APPEND)));

  00181	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00184	81 ff 4f 1c 00
	00		 cmp	 edi, 7247		; 00001c4fH
  0018a	75 04		 jne	 SHORT $LN39@gz_open
  0018c	33 c0		 xor	 eax, eax
  0018e	eb 28		 jmp	 SHORT $LN40@gz_open
$LN39@gz_open:
  00190	8b 4d fc	 mov	 ecx, DWORD PTR _exclusive$[ebp]
  00193	8d 87 4f 86 ff
	ff		 lea	 eax, DWORD PTR [edi-31153]
  00199	f7 d8		 neg	 eax
  0019b	1b c0		 sbb	 eax, eax
  0019d	25 08 fe ff ff	 and	 eax, -504		; fffffe08H
  001a2	05 00 02 00 00	 add	 eax, 512		; 00000200H
  001a7	f7 d9		 neg	 ecx
  001a9	1b c9		 sbb	 ecx, ecx
  001ab	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  001b1	0b c1		 or	 eax, ecx
  001b3	0d 01 01 00 00	 or	 eax, 257		; 00000101H
$LN40@gz_open:

; 233  : 
; 234  :     /* open the file with the appropriate flags (or just use fd) */
; 235  :     state->fd = fd > -1 ? fd : (
; 236  : #ifdef _WIN32
; 237  :         fd == -2 ? _wopen(path, oflag, 0666) :
; 238  : #endif
; 239  :         open(path, oflag, 0666));

  001b8	8b 4d 0c	 mov	 ecx, DWORD PTR _fd$[ebp]
  001bb	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  001c0	83 f9 ff	 cmp	 ecx, -1
  001c3	7e 04		 jle	 SHORT $LN43@gz_open
  001c5	8b c1		 mov	 eax, ecx
  001c7	eb 22		 jmp	 SHORT $LN42@gz_open
$LN43@gz_open:
  001c9	68 b6 01 00 00	 push	 438			; 000001b6H
  001ce	50		 push	 eax
  001cf	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  001d2	75 0b		 jne	 SHORT $LN41@gz_open
  001d4	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 __wopen
  001dd	eb 09		 jmp	 SHORT $LN52@gz_open
$LN41@gz_open:
  001df	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 _open
$LN52@gz_open:
  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN42@gz_open:
  001eb	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 240  :     if (state->fd == -1) {

  001ee	83 f8 ff	 cmp	 eax, -1
  001f1	75 1b		 jne	 SHORT $LN4@gz_open

; 241  :         free(state->path);

  001f3	8b 55 f8	 mov	 edx, DWORD PTR tv149[ebp]
  001f6	52		 push	 edx
  001f7	e8 00 00 00 00	 call	 _free

; 242  :         free(state);

  001fc	56		 push	 esi
  001fd	e8 00 00 00 00	 call	 _free
  00202	83 c4 08	 add	 esp, 8
$LN53@gz_open:

; 243  :         return NULL;

  00205	5e		 pop	 esi
  00206	5f		 pop	 edi
  00207	33 c0		 xor	 eax, eax
  00209	5b		 pop	 ebx

; 259  : }

  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c3		 ret	 0
$LN4@gz_open:

; 244  :     }
; 245  :     if (state->mode == GZ_APPEND)

  0020e	83 ff 01	 cmp	 edi, 1
  00211	75 07		 jne	 SHORT $LN3@gz_open

; 246  :         state->mode = GZ_WRITE;         /* simplify later checks */

  00213	c7 46 10 b1 79
	00 00		 mov	 DWORD PTR [esi+16], 31153 ; 000079b1H
$LN3@gz_open:

; 247  : 
; 248  :     /* save the current position for rewinding (only if reading) */
; 249  :     if (state->mode == GZ_READ) {

  0021a	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  00221	75 22		 jne	 SHORT $LN1@gz_open

; 250  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  00223	6a 01		 push	 1
  00225	33 ff		 xor	 edi, edi
  00227	57		 push	 edi
  00228	57		 push	 edi
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 __lseeki64
  0022f	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 251  :         if (state->start == -1) state->start = 0;

  00232	23 c2		 and	 eax, edx
  00234	83 c4 10	 add	 esp, 16			; 00000010H
  00237	89 56 3c	 mov	 DWORD PTR [esi+60], edx
  0023a	83 f8 ff	 cmp	 eax, -1
  0023d	75 06		 jne	 SHORT $LN1@gz_open
  0023f	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00242	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
$LN1@gz_open:

; 252  :     }
; 253  : 
; 254  :     /* initialize stream */
; 255  :     gz_reset(state);

  00245	e8 00 00 00 00	 call	 _gz_reset

; 256  : 
; 257  :     /* return stream */
; 258  :     return (gzFile)state;

  0024a	8b c6		 mov	 eax, esi
  0024c	5e		 pop	 esi
  0024d	5f		 pop	 edi
  0024e	5b		 pop	 ebx

; 259  : }

  0024f	8b e5		 mov	 esp, ebp
  00251	5d		 pop	 ebp
  00252	c3		 ret	 0
  00253	90		 npad	 1
$LN55@gz_open:
  00254	00 00 00 00	 DD	 $LN54@gz_open
  00258	00 00 00 00	 DD	 $LN18@gz_open
  0025c	00 00 00 00	 DD	 $LN19@gz_open
  00260	00 00 00 00	 DD	 $LN17@gz_open
  00264	00 00 00 00	 DD	 $LN25@gz_open
  00268	00 00 00 00	 DD	 $LN21@gz_open
  0026c	00 00 00 00	 DD	 $LN20@gz_open
  00270	00 00 00 00	 DD	 $LN27@gz_open
  00274	00 00 00 00	 DD	 $LN26@gz_open
  00278	00 00 00 00	 DD	 $LN22@gz_open
  0027c	00 00 00 00	 DD	 $LN50@gz_open
$LN48@gz_open:
  00280	00		 DB	 0
  00281	0a		 DB	 10			; 0000000aH
  00282	0a		 DB	 10			; 0000000aH
  00283	0a		 DB	 10			; 0000000aH
  00284	0a		 DB	 10			; 0000000aH
  00285	0a		 DB	 10			; 0000000aH
  00286	0a		 DB	 10			; 0000000aH
  00287	0a		 DB	 10			; 0000000aH
  00288	0a		 DB	 10			; 0000000aH
  00289	0a		 DB	 10			; 0000000aH
  0028a	0a		 DB	 10			; 0000000aH
  0028b	0a		 DB	 10			; 0000000aH
  0028c	0a		 DB	 10			; 0000000aH
  0028d	0a		 DB	 10			; 0000000aH
  0028e	0a		 DB	 10			; 0000000aH
  0028f	0a		 DB	 10			; 0000000aH
  00290	0a		 DB	 10			; 0000000aH
  00291	0a		 DB	 10			; 0000000aH
  00292	0a		 DB	 10			; 0000000aH
  00293	0a		 DB	 10			; 0000000aH
  00294	0a		 DB	 10			; 0000000aH
  00295	0a		 DB	 10			; 0000000aH
  00296	0a		 DB	 10			; 0000000aH
  00297	0a		 DB	 10			; 0000000aH
  00298	0a		 DB	 10			; 0000000aH
  00299	0a		 DB	 10			; 0000000aH
  0029a	0a		 DB	 10			; 0000000aH
  0029b	01		 DB	 1
  0029c	0a		 DB	 10			; 0000000aH
  0029d	0a		 DB	 10			; 0000000aH
  0029e	0a		 DB	 10			; 0000000aH
  0029f	0a		 DB	 10			; 0000000aH
  002a0	0a		 DB	 10			; 0000000aH
  002a1	0a		 DB	 10			; 0000000aH
  002a2	0a		 DB	 10			; 0000000aH
  002a3	0a		 DB	 10			; 0000000aH
  002a4	0a		 DB	 10			; 0000000aH
  002a5	0a		 DB	 10			; 0000000aH
  002a6	0a		 DB	 10			; 0000000aH
  002a7	02		 DB	 2
  002a8	0a		 DB	 10			; 0000000aH
  002a9	03		 DB	 3
  002aa	0a		 DB	 10			; 0000000aH
  002ab	0a		 DB	 10			; 0000000aH
  002ac	0a		 DB	 10			; 0000000aH
  002ad	0a		 DB	 10			; 0000000aH
  002ae	0a		 DB	 10			; 0000000aH
  002af	0a		 DB	 10			; 0000000aH
  002b0	0a		 DB	 10			; 0000000aH
  002b1	0a		 DB	 10			; 0000000aH
  002b2	0a		 DB	 10			; 0000000aH
  002b3	0a		 DB	 10			; 0000000aH
  002b4	0a		 DB	 10			; 0000000aH
  002b5	0a		 DB	 10			; 0000000aH
  002b6	04		 DB	 4
  002b7	0a		 DB	 10			; 0000000aH
  002b8	0a		 DB	 10			; 0000000aH
  002b9	0a		 DB	 10			; 0000000aH
  002ba	0a		 DB	 10			; 0000000aH
  002bb	05		 DB	 5
  002bc	0a		 DB	 10			; 0000000aH
  002bd	06		 DB	 6
  002be	0a		 DB	 10			; 0000000aH
  002bf	0a		 DB	 10			; 0000000aH
  002c0	0a		 DB	 10			; 0000000aH
  002c1	0a		 DB	 10			; 0000000aH
  002c2	0a		 DB	 10			; 0000000aH
  002c3	0a		 DB	 10			; 0000000aH
  002c4	0a		 DB	 10			; 0000000aH
  002c5	0a		 DB	 10			; 0000000aH
  002c6	0a		 DB	 10			; 0000000aH
  002c7	07		 DB	 7
  002c8	0a		 DB	 10			; 0000000aH
  002c9	0a		 DB	 10			; 0000000aH
  002ca	0a		 DB	 10			; 0000000aH
  002cb	0a		 DB	 10			; 0000000aH
  002cc	08		 DB	 8
  002cd	09		 DB	 9
_gz_open ENDP
PUBLIC	_gzseek64@16
; Function compile flags: /Ogtp
;	COMDAT _gzseek64@16
_TEXT	SEGMENT
tv405 = 8						; size = 8
_offset$ = 8						; size = 8
_gzseek64@16 PROC					; COMDAT
; _file$ = esi
; _whence$ = ecx

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 357  :     unsigned n;
; 358  :     z_off64_t ret;
; 359  :     gz_statep state;
; 360  : 
; 361  :     /* get internal structure and check integrity */
; 362  :     if (file == NULL)

  00005	85 f6		 test	 esi, esi

; 363  :         return -1;

  00007	74 28		 je	 SHORT $LN28@gzseek64

; 364  :     state = (gz_statep)file;
; 365  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00009	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000c	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  00012	74 08		 je	 SHORT $LN14@gzseek64
  00014	81 fa b1 79 00
	00		 cmp	 edx, 31153		; 000079b1H

; 366  :         return -1;

  0001a	75 15		 jne	 SHORT $LN28@gzseek64
$LN14@gzseek64:

; 367  : 
; 368  :     /* check that there's no error */
; 369  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  0001c	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0001f	85 c0		 test	 eax, eax
  00021	74 05		 je	 SHORT $LN13@gzseek64
  00023	83 f8 fb	 cmp	 eax, -5			; fffffffbH

; 370  :         return -1;

  00026	75 09		 jne	 SHORT $LN28@gzseek64
$LN13@gzseek64:

; 371  : 
; 372  :     /* can only seek from start or relative to current position */
; 373  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  00028	85 c9		 test	 ecx, ecx
  0002a	74 10		 je	 SHORT $LN20@gzseek64
  0002c	83 f9 01	 cmp	 ecx, 1
  0002f	74 19		 je	 SHORT $LN11@gzseek64
$LN28@gzseek64:

; 374  :         return -1;

  00031	83 c8 ff	 or	 eax, -1
  00034	0b d0		 or	 edx, eax

; 426  : }

  00036	5f		 pop	 edi
  00037	5b		 pop	 ebx
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN20@gzseek64:

; 375  : 
; 376  :     /* normalize offset to a SEEK_CUR specification */
; 377  :     if (whence == SEEK_SET)
; 378  :         offset -= state->x.pos;

  0003c	8b 5d 08	 mov	 ebx, DWORD PTR _offset$[ebp]
  0003f	2b 5e 08	 sub	 ebx, DWORD PTR [esi+8]
  00042	8b 7d 0c	 mov	 edi, DWORD PTR _offset$[ebp+4]
  00045	1b 7e 0c	 sbb	 edi, DWORD PTR [esi+12]
  00048	eb 12		 jmp	 SHORT $LN9@gzseek64
$LN11@gzseek64:

; 379  :     else if (state->seek)

  0004a	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0

; 380  :         offset += state->skip;

  0004e	8b 5d 08	 mov	 ebx, DWORD PTR _offset$[ebp]
  00051	8b 7d 0c	 mov	 edi, DWORD PTR _offset$[ebp+4]
  00054	74 06		 je	 SHORT $LN9@gzseek64
  00056	03 5e 50	 add	 ebx, DWORD PTR [esi+80]
  00059	13 7e 54	 adc	 edi, DWORD PTR [esi+84]
$LN9@gzseek64:

; 381  :     state->seek = 0;

  0005c	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0

; 382  : 
; 383  :     /* if within raw area while reading, just go there */
; 384  :     if (state->mode == GZ_READ && state->how == COPY &&
; 385  :             state->x.pos + offset >= 0) {

  00063	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  00069	75 6d		 jne	 SHORT $LN8@gzseek64
  0006b	83 7e 30 01	 cmp	 DWORD PTR [esi+48], 1
  0006f	75 67		 jne	 SHORT $LN8@gzseek64
  00071	8b c3		 mov	 eax, ebx
  00073	03 46 08	 add	 eax, DWORD PTR [esi+8]
  00076	8b cf		 mov	 ecx, edi
  00078	13 4e 0c	 adc	 ecx, DWORD PTR [esi+12]
  0007b	89 4d 0c	 mov	 DWORD PTR tv405[ebp+4], ecx
  0007e	78 58		 js	 SHORT $LN8@gzseek64
  00080	7f 04		 jg	 SHORT $LN21@gzseek64
  00082	85 c0		 test	 eax, eax
  00084	72 52		 jb	 SHORT $LN8@gzseek64
$LN21@gzseek64:

; 386  :         ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
; 387  :         if (ret == -1)

  00086	33 c0		 xor	 eax, eax
  00088	8b cb		 mov	 ecx, ebx
  0008a	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0008c	6a 01		 push	 1
  0008e	8b d7		 mov	 edx, edi
  00090	1b d0		 sbb	 edx, eax
  00092	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00095	52		 push	 edx
  00096	51		 push	 ecx
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 __lseeki64
  0009d	23 c2		 and	 eax, edx
  0009f	83 c4 10	 add	 esp, 16			; 00000010H
  000a2	83 f8 ff	 cmp	 eax, -1

; 388  :             return -1;

  000a5	74 8a		 je	 SHORT $LN28@gzseek64

; 389  :         state->x.have = 0;

  000a7	33 c0		 xor	 eax, eax

; 390  :         state->eof = 0;
; 391  :         state->past = 0;
; 392  :         state->seek = 0;
; 393  :         gz_error(state, Z_OK, NULL);

  000a9	50		 push	 eax
  000aa	8b ce		 mov	 ecx, esi
  000ac	89 06		 mov	 DWORD PTR [esi], eax
  000ae	89 46 40	 mov	 DWORD PTR [esi+64], eax
  000b1	89 46 44	 mov	 DWORD PTR [esi+68], eax
  000b4	89 46 58	 mov	 DWORD PTR [esi+88], eax
  000b7	e8 00 00 00 00	 call	 _gz_error
  000bc	83 c4 04	 add	 esp, 4

; 394  :         state->strm.avail_in = 0;
; 395  :         state->x.pos += offset;

  000bf	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 396  :         return state->x.pos;

  000c2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c5	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0
  000cc	11 7e 0c	 adc	 DWORD PTR [esi+12], edi
  000cf	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]

; 426  : }

  000d2	5f		 pop	 edi
  000d3	5b		 pop	 ebx
  000d4	5d		 pop	 ebp
  000d5	c2 08 00	 ret	 8
$LN8@gzseek64:

; 397  :     }
; 398  : 
; 399  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 400  :     if (offset < 0) {

  000d8	85 ff		 test	 edi, edi
  000da	7f 39		 jg	 SHORT $LN3@gzseek64
  000dc	7c 04		 jl	 SHORT $LN22@gzseek64
  000de	85 db		 test	 ebx, ebx
  000e0	73 33		 jae	 SHORT $LN3@gzseek64
$LN22@gzseek64:

; 401  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  000e2	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH

; 402  :             return -1;

  000e8	0f 85 43 ff ff
	ff		 jne	 $LN28@gzseek64

; 403  :         offset += state->x.pos;

  000ee	03 5e 08	 add	 ebx, DWORD PTR [esi+8]
  000f1	13 7e 0c	 adc	 edi, DWORD PTR [esi+12]

; 404  :         if (offset < 0)                     /* before start of file! */

  000f4	85 ff		 test	 edi, edi
  000f6	7f 0e		 jg	 SHORT $LN4@gzseek64
  000f8	0f 8c 33 ff ff
	ff		 jl	 $LN28@gzseek64
  000fe	85 db		 test	 ebx, ebx

; 405  :             return -1;

  00100	0f 82 2b ff ff
	ff		 jb	 $LN28@gzseek64
$LN4@gzseek64:

; 406  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  00106	56		 push	 esi
  00107	e8 00 00 00 00	 call	 _gzrewind@4
  0010c	83 f8 ff	 cmp	 eax, -1

; 407  :             return -1;

  0010f	0f 84 1c ff ff
	ff		 je	 $LN28@gzseek64
$LN3@gzseek64:

; 408  :     }
; 409  : 
; 410  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 411  :     if (state->mode == GZ_READ) {

  00115	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  0011c	75 27		 jne	 SHORT $LN2@gzseek64

; 412  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
; 413  :             (unsigned)offset : state->x.have;

  0011e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00120	33 c0		 xor	 eax, eax
  00122	3b c7		 cmp	 eax, edi
  00124	7f 0a		 jg	 SHORT $LN18@gzseek64
  00126	7c 04		 jl	 SHORT $LN24@gzseek64
  00128	3b cb		 cmp	 ecx, ebx
  0012a	77 04		 ja	 SHORT $LN18@gzseek64
$LN24@gzseek64:
  0012c	8b c1		 mov	 eax, ecx
  0012e	eb 02		 jmp	 SHORT $LN19@gzseek64
$LN18@gzseek64:
  00130	8b c3		 mov	 eax, ebx
$LN19@gzseek64:

; 414  :         state->x.have -= n;
; 415  :         state->x.next += n;

  00132	01 46 04	 add	 DWORD PTR [esi+4], eax
  00135	2b c8		 sub	 ecx, eax
  00137	89 0e		 mov	 DWORD PTR [esi], ecx

; 416  :         state->x.pos += n;

  00139	33 c9		 xor	 ecx, ecx
  0013b	01 46 08	 add	 DWORD PTR [esi+8], eax
  0013e	11 4e 0c	 adc	 DWORD PTR [esi+12], ecx

; 417  :         offset -= n;

  00141	2b d8		 sub	 ebx, eax
  00143	1b f9		 sbb	 edi, ecx
$LN2@gzseek64:

; 418  :     }
; 419  : 
; 420  :     /* request skip (if not zero) */
; 421  :     if (offset) {

  00145	8b c3		 mov	 eax, ebx
  00147	0b c7		 or	 eax, edi
  00149	74 0d		 je	 SHORT $LN1@gzseek64

; 422  :         state->seek = 1;

  0014b	c7 46 58 01 00
	00 00		 mov	 DWORD PTR [esi+88], 1

; 423  :         state->skip = offset;

  00152	89 5e 50	 mov	 DWORD PTR [esi+80], ebx
  00155	89 7e 54	 mov	 DWORD PTR [esi+84], edi
$LN1@gzseek64:

; 424  :     }
; 425  :     return state->x.pos + offset;

  00158	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0015e	03 c3		 add	 eax, ebx
  00160	13 d7		 adc	 edx, edi

; 426  : }

  00162	5f		 pop	 edi
  00163	5b		 pop	 ebx
  00164	5d		 pop	 ebp
  00165	c2 08 00	 ret	 8
_gzseek64@16 ENDP
_TEXT	ENDS
PUBLIC	_gzopen_w@8
; Function compile flags: /Ogtp
;	COMDAT _gzopen_w@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen_w@8 PROC					; COMDAT

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 299  :     return gz_open(path, -2, mode);

  00003	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  00006	6a fe		 push	 -2			; fffffffeH
  00008	50		 push	 eax
  00009	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0000c	e8 00 00 00 00	 call	 _gz_open
  00011	83 c4 08	 add	 esp, 8

; 300  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_gzopen_w@8 ENDP
_TEXT	ENDS
PUBLIC	_gzdopen@8
; Function compile flags: /Ogtp
;	COMDAT _gzdopen@8
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzdopen@8 PROC						; COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 282  :     char *path;         /* identifier for error messages */
; 283  :     gzFile gz;
; 284  : 
; 285  :     if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _fd$[ebp]
  00008	83 ff ff	 cmp	 edi, -1
  0000b	74 39		 je	 SHORT $LN1@gzdopen
  0000d	6a 13		 push	 19			; 00000013H
  0000f	e8 00 00 00 00	 call	 _malloc
  00014	8b f0		 mov	 esi, eax
  00016	83 c4 04	 add	 esp, 4
  00019	85 f6		 test	 esi, esi
  0001b	74 29		 je	 SHORT $LN1@gzdopen

; 287  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */

  0001d	57		 push	 edi
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 _sprintf

; 288  :     gz = gz_open(path, fd, mode);

  00029	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0002c	57		 push	 edi
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 _gz_open

; 289  :     free(path);

  00033	56		 push	 esi
  00034	8b f8		 mov	 edi, eax
  00036	e8 00 00 00 00	 call	 _free
  0003b	83 c4 18	 add	 esp, 24			; 00000018H

; 290  :     return gz;

  0003e	8b c7		 mov	 eax, edi
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 291  : }

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN1@gzdopen:
  00046	5f		 pop	 edi

; 286  :         return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi

; 291  : }

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
_gzdopen@8 ENDP
_TEXT	ENDS
PUBLIC	_gzopen@8
; Function compile flags: /Ogtp
;	COMDAT _gzopen@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen@8 PROC						; COMDAT

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 266  :     return gz_open(path, -1, mode);

  00003	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  00006	6a ff		 push	 -1
  00008	50		 push	 eax
  00009	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0000c	e8 00 00 00 00	 call	 _gz_open
  00011	83 c4 08	 add	 esp, 8

; 267  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_gzopen@8 ENDP
PUBLIC	_gzseek@12
; Function compile flags: /Ogtp
;	COMDAT _gzseek@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek@12 PROC						; COMDAT

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx

; 434  :     z_off64_t ret;
; 435  : 
; 436  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _whence$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00011	99		 cdq
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _gzseek64@16
  00019	8b c8		 mov	 ecx, eax
  0001b	8b f2		 mov	 esi, edx

; 437  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0001d	99		 cdq
  0001e	3b c8		 cmp	 ecx, eax
  00020	75 0d		 jne	 SHORT $LN3@gzseek
  00022	3b f2		 cmp	 esi, edx
  00024	75 09		 jne	 SHORT $LN3@gzseek
  00026	8b c1		 mov	 eax, ecx

; 438  : }

  00028	5e		 pop	 esi
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
$LN3@gzseek:

; 437  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0002f	83 c8 ff	 or	 eax, -1

; 438  : }

  00032	5e		 pop	 esi
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 0c 00	 ret	 12			; 0000000cH
_gzseek@12 ENDP
END
